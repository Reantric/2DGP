import numpy as np
from scipy.interpolate import make_interp_spline, BSpline
import scipy.interpolate as interpolate
from timeit import default_timer as timer
import time, datetime

# Required imports

spacing = 18000  # How far away every new x value should be


# A B C ...
# x1 y1A y1B y1C ...
# x2 y2A y2B y2C ...
# x3 y3A y3B y3C ...
# .
# .
# .

def espace(data):
    """
    :param data: A dictionary with x values and y values from a text file
    :return: A new dictionary with the x values linspaced and the y values interpolated (PCHIP)
    """
    xSpl = [a[0] for a in data[key[0]]]  # Get all the x values from the dictionary (Since the x-values are shared
    # between all values in the dictionary, it does not matter which one is taken

    coords = {x[a]: [] for a in range(numOfDataPoints)}  # Creates a new dictionary with the x value being the key
    # and the values being the y values that will be filled in
    xLength = len(x)  # Length of linspaced x

    for o in data:
        initialDash = 0
        endingDash = 0
        ySpl = [b[1] for b in data[o]]  # Where o is key
        for g in range(len(ySpl)):
            if ySpl[g] == "-":  # If there is a dash in the y-value
                initialDash += 1
            else:
                break

        for h in range(len(ySpl) - 1, 0, -1):  # Going backwards
            if ySpl[h] == "-":  # If there is a dash in the y-value
                endingDash += 1
            else:
                break

        tempX = [xSpl[m] for m in range(len(xSpl)) if ySpl[m] != "-"]  # Get all x's where their corresponding y does
        # not have a dash
        ySpl = [item for item in ySpl if item != "-"]  # Get all y values without a dash

        #  print(endingDash)
        #  print(initialDash) Debugging

        spl = interpolate.PchipInterpolator(np.asarray(tempX), np.asarray(ySpl), extrapolate=True)  # Create a PCHIP
        # interpolator that will interpolate the data

        limitAmtS = int((xSpl[initialDash] - xSpl[0]) / spacing)  # Find the point where the dashes do not appear
        # anymore in the linspaced x from the start using initialDash
        limitAmtE = int((xSpl[-1] - xSpl[-endingDash - 1]) / spacing)  # Find the point where the dashes do not appear
        # anymore in the linspaced x from the end using endingDash

        zeroList = [-1] * limitAmtS  # If there are dashes in the beginning, insert -1 in the interpolated dataset
        infList = [ySpl[-1]] * limitAmtE  # If there are dashes in the end, insert -1 in the interpolated dataset
        dataPointY = np.concatenate(
            [zeroList, spl(x[limitAmtS:xLength - limitAmtE]), infList])  # Concatenate all lists/arrays

        for u in range(numOfDataPoints):
            coords[x[u]] += [round(dataPointY[u], 5)]  # Add the dataset to coords one by one (len(x) == len(dataPointY)

    return coords


def isNum(n):
    """
    :param n: Any number
    :return: Number is a float
    """
    try:
        float(n)
    except ValueError:
        return False
    else:
        return True


with open("one.txt", mode='r+') as f:  # Open any text file with values in it separated by spaces
    """
    v is not used anywhere outside of this
    """
    f.seek(0)  # Go to the beginning of the file
    key = f.readline()  # Get the first line of the text file where the names should be
    key = key.split()  # Split the String 'key' into a list
    data = f.readlines()  # Get a list of all the data in the text file
    d = {key[a]: [] for a in range(len(key))}  # Create a dictionary to store x values and y values under a named key
    # d[name] = [(x1,y1),(x2,y2),(x3,y3)] where x values are the same for every name

    for v in data:
        v = v.split()  # Split each line of the data
        date = v.pop(0)  # Get the first item of v and delete the first item from the list
        # x = int(v.pop(0)) If an integer is wanted for the x-axis
        x = time.mktime(datetime.datetime.strptime(f'{date[6:]}-{date[:2]}-{date[3:5]}', '%Y-%m-%d').timetuple())
        # Turns a YY-MM-DD into a Unix Timestamp

        # v = list(map(int, v)) # If an integer is wanted for the x-axis
        v = [float(e) if isNum(e) else "-" for e in v]  # If each element in v is a number and not a dash
        for i in range(len(key)):
            d[key[i]] += [(x, v[i])]  # Append a tuple (x,y) into the dictionary with the appropriate name key

    # TODO Fix the efficiency of finding the maximum and minimum X value
    xMax = list(d.values())[0][-1][0]
    xMin = list(d.values())[0][0][0]

f.close()  # Close the file

numOfDataPoints = int((xMax - xMin) / spacing)  # Gets the total number of datapoints generated by the spacing

x = np.linspace(xMin, xMax, numOfDataPoints)  # Linspace the original x values to fit numOfDataPoints amount of x values

with open("datas.txt", mode='w+') as f:  # Create a new text file
    """
     Write all the interpolated data into a new text file 
    """
    f.write(' '.join(key) + "\n")  # The first line of the new text file is the key

    start = timer()  # Check how long program takes to run
    print("Calculating")
    coords = espace(d)  # Get the dictionary returned by espace
    print("Beginning!")

    statement = ""  # Create an empty String to be populated

    for ind in range(numOfDataPoints - 1):
        if ind % 3000 == 0:  # Check every 3000 times the loop is run and output a % of completion
            print(f"{100 * ind / (numOfDataPoints - 1)}% done!")

        statement += f"{str(round(x[ind], 5))} " + " ".join(map(str, coords[x[ind]])) + "\n"  # Add to the String the
        # dataset information in the same format as the original

        if ind % 8000 == 0:  # Every 8000 times the loop is run, write the statement (so that the statement doesn't
            # get too big)
            f.write(statement)
            statement = ""  # Reset the statement

    f.write(statement)  # Write whatever is left of the statement
    end = timer()  # End the timer

    print(f"Finished in {(end - start)} sec")

f.close()
print("Now complete!")

# program works! <160 lines !!!!!
